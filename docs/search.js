window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "nanopyx", "modulename": "nanopyx", "kind": "module", "doc": "<p>Nanoscopy Python library (NanoPyx, the successor to NanoJ) - focused on light microscopy and super-resolution imaging</p>\n"}, {"fullname": "nanopyx.core", "modulename": "nanopyx.core", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis", "modulename": "nanopyx.core.analysis", "kind": "module", "doc": "<p>Module containing image analysis functions.\nIncludes functions for cross correlations and Pearson's correlation.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm", "modulename": "nanopyx.core.analysis.ccm", "kind": "module", "doc": "<p>Module used for creating cross correlation matrices for image stacks.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.ccm", "modulename": "nanopyx.core.analysis.ccm.ccm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.ccm.calculate_ccm", "modulename": "nanopyx.core.analysis.ccm.ccm", "qualname": "calculate_ccm", "kind": "function", "doc": "<p>Function used to generate a cross correlation matrix of an image stack.\nCross correlation is calculated using either the first image of the stack or the previous image.\nCross correlation values are normalized by the minimum and maximum Pearson's correlation between the two\nimages.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img_stack</strong>:  numpy array with shape (t, y, x)</li>\n<li><strong>ref</strong>:  either 0 or 1, 0 is used to calculate the ccm based on the first frame, 1 used to calculate based on the previous frame</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x), corresponding to the cross correlation matrix</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.ccm.calculate_ccm_from_ref", "modulename": "nanopyx.core.analysis.ccm.ccm", "qualname": "calculate_ccm_from_ref", "kind": "function", "doc": "<p>Function used to generate a cross correlation matrix of an image stack.\nCross correlation is calculated using a static image frame.\nCross correlation values are normalized by the minimum and maximum Pearson's correlation between the two\nimages.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img_stack</strong>:  numpy array with shape (t, y, x)</li>\n<li><strong>img_ref</strong>:  numpy array with shape (y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x), corresponding to the cross correlation matrix</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "modulename": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.cross_correlation_elastic.calculate_translation_mask", "modulename": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "qualname": "calculate_translation_mask", "kind": "function", "doc": "<p>Function used to calculate a translation mask between 2 different images.\nMethod based on dividing both images in smaller blocks and calculate cross correlation matrix between corresponding\nblocks. From the ccm, the shift between the two images is calculated for each block and a translation matrix is\nusing the shifts in the center position of each block and then interpolating the remaining translation mask.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img_slice</strong>:  numpy array with shape (y, x); image to be used for translation mask calculation</li>\n<li><strong>img_ref</strong>:  numpy array with shape (y, x); image to be used as reference for translation mask calculation</li>\n<li><strong>max_shift</strong>:  int; maximum shift accepted between each corresponding block, in pixels.</li>\n<li><strong>blocks_per_axis</strong>:  int; number of blocks for both axis</li>\n<li><strong>min_similarity</strong>:  float; minimum similarity (cross correlation value after normalization) between corresponding\nblocks.</li>\n<li><strong>method</strong>:  str, either \"subpixel\" or \"max\"; defaults to \"subpixel\"; subpixel uses a minimizer to achieve\nsubpixel precision in shift calculation. max simply takes the coordinates corresponding to the max value of the ccm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (y, x) where width is equal to two times the width of the original image.\n  [:, :width/2] corresponds to the translation mask for x and [:, width/2:] corresponds to the translation mask for y.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img_slice</span>,</span><span class=\"param\">\t<span class=\"n\">img_ref</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;subpixel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.cross_correlation_elastic.get_shift_from_ccm_slice", "modulename": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "qualname": "get_shift_from_ccm_slice", "kind": "function", "doc": "<p>Function used to calculate the shift corresponding to the maximum correlation between two images.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice_ccm</strong>:  numpy array with shape (y, x);</li>\n<li><strong>method</strong>:  str, either \"subpixel\" or \"max\"; defaults to \"subpixel\"; subpixel uses a minimizer to achieve\nsubpixel precision in shift calculation. max simply takes the coordinates corresponding to the max value of the ccm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple of floats; values corresponding to shift_x and shift_y, in this order.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">slice_ccm</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;subpixel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer", "kind": "class", "doc": "<p>Class GetMaxOptimizer, used to extract the maximum value from a cross correlation matrix with subpixel precision.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.__init__", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.__init__", "kind": "function", "doc": "<p>Creates an instance of GetMaxOptimizer.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice_ccm</strong>:  numpy array with shape (y, x); ccm from which to extract the maximum value with subpixel\nprecision.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">slice_ccm</span></span>)</span>"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.get_interpolated_px_value_interp2d", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.get_interpolated_px_value_interp2d", "kind": "function", "doc": "<p>Method to be used for calculating the interpolated values of cross correlation matrices.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coords</strong>:  tuple of coordinates.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of cross correlation matrix at given coordinates.\n  For minimizer reasons -> negatives values become positive and positive become negative.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coords</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.get_max", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.get_max", "kind": "function", "doc": "<p>Method used to calculate the maximum value and corresponding coordinates of a ccm. Uses a minimizer approach.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple; coordinates of maximum value of ccm with subpixel precision</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.check_even_square", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "check_even_square", "kind": "function", "doc": "<p>Function used to check if an image array is an even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool, True if an image array is an even square</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.get_closest_even_square_size", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "get_closest_even_square_size", "kind": "function", "doc": "<p>Function used to calculate the closest even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x); image to be cropped</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int; value of dimensions to be used for cropping</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.make_even_square", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "make_even_square", "kind": "function", "doc": "<p>Function used to crop an image array into an even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x); image to be cropped</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.pearson_correlation", "modulename": "nanopyx.core.analysis.pearson_correlation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.pearson_correlation.calculate_ppmcc", "modulename": "nanopyx.core.analysis.pearson_correlation", "qualname": "calculate_ppmcc", "kind": "function", "doc": "<p>Calculates the Pearson's correlation between two images after applying a shift.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im1</strong>:  numpy array with shape (y, x)</li>\n<li><strong>im2</strong>:  numpy array with shape (y, x)</li>\n<li><strong>shift_x</strong>:  int; value to shift images in x dimension</li>\n<li><strong>shift_y</strong>:  int; value to shift images in y dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of Pearson's Correlation function after shifting the two images.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.pearson_correlation.pearson_correlation", "modulename": "nanopyx.core.analysis.pearson_correlation", "qualname": "pearson_correlation", "kind": "function", "doc": "<p>Calculates the Pearson's correlation between two images.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im1</strong>:  numpy array with shape (y, x)</li>\n<li><strong>im2</strong>:  numpy array with shape (y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of Pearson's correlation between two images</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image", "modulename": "nanopyx.core.image", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.blocks", "modulename": "nanopyx.core.image.blocks", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.blocks.assemble_frame_from_blocks", "modulename": "nanopyx.core.image.blocks", "qualname": "assemble_frame_from_blocks", "kind": "function", "doc": "<p>Function used to assemble a full image from blocks</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>blocks_stack</strong>:  numpy array with shape (n_blocks, y, x)</li>\n<li><strong>n_blocks_height</strong>:  int; number of blocks in y</li>\n<li><strong>n_blocks_width</strong>:  int; number of blocks in x</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (y<em>n_blocks, x</em>n_blocks)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">blocks_stack</span>, </span><span class=\"param\"><span class=\"n\">n_blocks_height</span>, </span><span class=\"param\"><span class=\"n\">n_blocks_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.rcc", "modulename": "nanopyx.core.image.rcc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.rcc.calculate_x_corr", "modulename": "nanopyx.core.image.rcc", "qualname": "calculate_x_corr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">im2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.rcc.get_image_shift", "modulename": "nanopyx.core.image.rcc", "qualname": "get_image_shift", "kind": "function", "doc": "<p>Computes the shift from im1 to ima2</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">im2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">box</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.rcc.rcc", "modulename": "nanopyx.core.image.rcc", "qualname": "rcc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im_frames</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.rcc.minimize_shifts", "modulename": "nanopyx.core.image.rcc", "qualname": "minimize_shifts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shifts_x</span>, </span><span class=\"param\"><span class=\"n\">shifts_y</span>, </span><span class=\"param\"><span class=\"n\">shifts_z</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io", "modulename": "nanopyx.core.io", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.checksum", "modulename": "nanopyx.core.io.checksum", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.checksum.get_checksum", "modulename": "nanopyx.core.io.checksum", "qualname": "get_checksum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.unique_names", "modulename": "nanopyx.core.io.unique_names", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.zip_image_loader", "modulename": "nanopyx.core.io.zip_image_loader", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.__init__", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_shape", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_shape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_dtype", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_dtype", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_thumb", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_thumb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.close", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.close", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.kernels", "modulename": "nanopyx.core.kernels", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr", "modulename": "nanopyx.core.sr", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map", "modulename": "nanopyx.core.sr.error_map", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.__init__", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.optimise", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.optimise", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">fixedSigma</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.getRSE", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.getRSE", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.getRSP", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.getRSP", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.get_sigma", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.get_sigma", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.calculate_alpha_beta", "modulename": "nanopyx.core.sr.error_map", "qualname": "calculate_alpha_beta", "kind": "function", "doc": "<p>Gaussian blurs imSR image and calculates linear regressino again imRef</p>\n\n<p>Args:\n    sigma (float): gaussian blur sigma\n    imRef (np.ndarray): reference image (generally a difraction limited equivalent)\n    imSR (np.ndarray): super-resolution image</p>\n\n<p>Returns:\n    tuple[float, float]: alpha and beta for linear regression</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.sigma_function_to_optimize", "modulename": "nanopyx.core.sr.error_map", "qualname": "sigma_function_to_optimize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc", "modulename": "nanopyx.core.sr.frc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.frc.ThresholdMethod", "modulename": "nanopyx.core.sr.frc", "qualname": "ThresholdMethod", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.frc.ThresholdMethod.__init__", "modulename": "nanopyx.core.sr.frc", "qualname": "ThresholdMethod.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.sr.frc.pad", "modulename": "nanopyx.core.sr.frc", "qualname": "pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_frc_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_frc_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span>, </span><span class=\"param\"><span class=\"n\">im2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_smoothed_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "get_smoothed_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_threshold_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_threshold_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_intersections", "modulename": "nanopyx.core.sr.frc", "qualname": "get_intersections", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">threshold_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_correct_intersection", "modulename": "nanopyx.core.sr.frc", "qualname": "get_correct_intersection", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">intersections</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_square_tapered_image", "modulename": "nanopyx.core.sr.frc", "qualname": "get_square_tapered_image", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_window_function", "modulename": "nanopyx.core.sr.frc", "qualname": "get_window_function", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">taper</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_interpolated_values", "modulename": "nanopyx.core.sr.frc", "qualname": "get_interpolated_values", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">images</span>, </span><span class=\"param\"><span class=\"n\">maxx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_fire_number_from_FRC_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_fire_number_from_FRC_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_fire_number", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_fire_number", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span>, </span><span class=\"param\"><span class=\"n\">im2</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.do_plot", "modulename": "nanopyx.core.sr.frc", "qualname": "do_plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span>, </span><span class=\"param\"><span class=\"n\">smooth_frc</span>, </span><span class=\"param\"><span class=\"n\">tm</span>, </span><span class=\"param\"><span class=\"n\">fire</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.srrf", "modulename": "nanopyx.core.sr.srrf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.srrf.CalculateRadiality", "modulename": "nanopyx.core.sr.srrf", "qualname": "CalculateRadiality", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.srrf.CalculateRadiality.__init__", "modulename": "nanopyx.core.sr.srrf", "qualname": "CalculateRadiality.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "nanopyx.core.sr.srrf.CalculateRadiality.calculate", "modulename": "nanopyx.core.sr.srrf", "qualname": "CalculateRadiality.calculate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform", "modulename": "nanopyx.core.transform", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.binning", "modulename": "nanopyx.core.transform.binning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.binning.rebin_2d", "modulename": "nanopyx.core.transform.binning", "qualname": "rebin_2d", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr: numpy array with any shape as long as last two dimensions are y, x (example</strong>:  time, channel, z, y, x)</li>\n<li><strong>bin_factor</strong>:  factor used to bin dimensions</li>\n<li><strong>mode</strong>:  can be either sum, mean or max, defaults to sum if not specified or not valid mode</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>binned array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">bin_factor</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;sum&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise", "modulename": "nanopyx.core.transform.image_add_random_noise", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.addMixedGaussianPoissonNoise", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "addMixedGaussianPoissonNoise", "kind": "function", "doc": "<p>Add mixed Gaussian-Poisson noise to an image, pure cython version</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>image : numpy.ndarray\n    The image to add noise to\ngaussSigma : float\n    The standard deviation of the Gaussian noise\ngaussMean : float\n    The mean of the Gaussian noise</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.addMixedGaussianPoissonNoise2", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "addMixedGaussianPoissonNoise2", "kind": "function", "doc": "<p>Add mixed Gaussian-Poisson noise to an image, pure numpy version</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>image : numpy.ndarray\n    The image to add noise to\ngaussSigma : float\n    The standard deviation of the Gaussian noise\ngaussMean : float\n    The mean of the Gaussian noise</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.addPerlinNoise", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "addPerlinNoise", "kind": "function", "doc": "<p>Add perlin noise to an image</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>image : numpy.ndarray\n    The image to add noise to\namp : int\n    The amplitude of the noise\noffset : int\n    The offset of the noise\nf : float\n    The frequency of the noise\noctaves : int\n    The number of octaves\npersistence : float\n    The persistence of the noise\nlacunarity : float\n    The lacunarity of the noise\nrepeatx : float\n    The repeat of the noise in the x direction\nrepeaty : float\n    The repeat of the noise in the y direction</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.getPerlinNoise", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "getPerlinNoise", "kind": "function", "doc": "<p>Return a perlin noise image</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>w : int\n    The width of the image\nh : int\n    The height of the image\namp : int\n    The amplitude of the noise\noffset : int\n    The offset of the noise\nf : float\n    The frequency of the noise\noctaves : int\n    The number of octaves of the noise\npersistence : float\n    The persistence of the noise\nlacunarity : float\n    The lacunarity of the noise\nrepeatx : float\n    The repeat in x of the noise\nrepeaty : float\n    The repeat in y of the noise</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.getSimplexNoise", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "getSimplexNoise", "kind": "function", "doc": "<p>Return a simplex noise image\nREF: <a href=\"https://github.com/lmas/opensimplex\">https://github.com/lmas/opensimplex</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>w : int\n    The width of the image\nh : int\n    The height of the image\nf : int\n    The frequency of the noise</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.addSquares", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "addSquares", "kind": "function", "doc": "<p>Add random squares to an image</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>image : numpy.ndarray\n    The image to add the squares to\nvmax : float\n    The maximum value of the squares\nvmin : float\n    The minimum value of the squares\nnSquares : int\n    The number of squares to add</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.getSquares", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "getSquares", "kind": "function", "doc": "<p>Return an image with random squares</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>w : int\n    Width of the image\nh : int\n    Height of the image\nvmax : float\n    Maximum value of the squares\nvmin : float\n    Minimum value of the squares\nnSquares : int\n    Number of squares to add</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>image : np.ndarray\n    Image with random squares</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.addRamp", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "addRamp", "kind": "function", "doc": "<p>Adds a ramp from vmin to vmax to the image</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>image : numpy.ndarray\n    The image to add the ramp to\nvmax : float\n    The maximum value of the ramp\nvmin : float\n    The minimum value of the ramp</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.getRamp", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "getRamp", "kind": "function", "doc": "<p>Returns a 2D array of size (w, h) with a ramp from vmin to vmax</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>w : int\n    Width of the image\nh : int\n    Height of the image\nvmax : float\n    Maximum value of the ramp\nvmin : float\n    Minimum value of the ramp</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_add_random_noise.test_logFactorial", "modulename": "nanopyx.core.transform.image_add_random_noise", "qualname": "test_logFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify", "modulename": "nanopyx.core.transform.image_magnify", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.image_magnify.fourier_zoom_2d", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "fourier_zoom_2d", "kind": "function", "doc": "<p>Zoom an image by zero-padding its Discrete Fourier transform.</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n\n<p>REF: based on <a href=\"https://github.com/centreborelli/fourier\">https://github.com/centreborelli/fourier</a>\nCredit goes to Carlo de Franchis <a href=\"&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x63;&#97;&#114;&#108;&#x6f;&#46;&#100;&#101;&#x2d;&#x66;&#114;&#97;&#x6e;&#99;&#104;&#105;&#x73;&#64;&#101;&#110;&#x73;&#x2d;&#112;a&#x72;&#105;&#115;&#45;&#x73;&#x61;&#99;&#x6c;&#97;&#121;&#46;&#102;&#114;\">&#x63;&#97;&#114;&#108;&#x6f;&#46;&#100;&#101;&#x2d;&#x66;&#114;&#97;&#x6e;&#99;&#104;&#105;&#x73;&#64;&#101;&#110;&#x73;&#x2d;&#112;a&#x72;&#105;&#115;&#45;&#x73;&#x61;&#99;&#x6c;&#97;&#121;&#46;&#102;&#114;</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.catmull_rom_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "catmull_rom_zoom", "kind": "function", "doc": "<p>Zoom an image by Catmull-Rom interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n\n<p>REF: based on <a href=\"https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java\">https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.lanczos_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "lanczos_zoom", "kind": "function", "doc": "<p>Zoom an image by Lanczos interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.\n    taps (int): The number of taps (interpolation points) to use in the Lanczos kernel.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.bicubic_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "bicubic_zoom", "kind": "function", "doc": "<p>Zoom an image by bicubic interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.scipy_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "scipy_zoom", "kind": "function", "doc": "<p>Zoom an image by SciPy interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.skimage_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "skimage_zoom", "kind": "function", "doc": "<p>Zoom an image by scikit-image interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.cv2_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "cv2_zoom", "kind": "function", "doc": "<p>Zoom an image by OpenCV interpolation</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_shift", "modulename": "nanopyx.core.transform.image_shift", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation", "modulename": "nanopyx.core.transform.interpolation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.bicubic", "modulename": "nanopyx.core.transform.interpolation.bicubic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.bicubic.magnify", "modulename": "nanopyx.core.transform.interpolation.bicubic", "qualname": "magnify", "kind": "function", "doc": "<p>Magnify an image by a factor of magnification using bicubic spline interpolation.</p>\n\n<p>Parameters:\n    im (np.ndarray): image to magnify.\n    magnification (int): magnification factor.</p>\n\n<p>Returns:\n    Magnified image (np.ndarray).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.bicubic.shift", "modulename": "nanopyx.core.transform.interpolation.bicubic", "qualname": "shift", "kind": "function", "doc": "<p>Shift an image by (dx, dy) using bicubic spline interpolation.</p>\n\n<p>im (np.ndarray): image to shift.\ndx (float): shift along x-axis.\ndy (float): shift along y-axis.</p>\n\n<p>Returns:\nShifted image (np.ndarray).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom.interpolate", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "qualname": "interpolate", "kind": "function", "doc": "<p>Interpolate image using Catmull-Rom interpolation.</p>\n\n<p>im (np.ndarray): image to interpolate.\nx (float): x-coordinate to interpolate at.\ny (float): y-coordinate to interpolate at.</p>\n\n<p>Returns:\nInterpolated pixel value (float).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom.magnify", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "qualname": "magnify", "kind": "function", "doc": "<p>Magnify image.</p>\n\n<p>im (np.ndarray): image to magnify.\nmagnification (int): magnification factor.</p>\n\n<p>Returns:\nMagnified image (np.ndarray).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom.shift", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "qualname": "shift", "kind": "function", "doc": "<p>Shift image.</p>\n\n<p>im (np.ndarray): image to shift.\ndx (float): shift along x-axis.\ndy (float): shift along y-axis.</p>\n\n<p>Returns:\nShifted image (np.ndarray).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.fft", "modulename": "nanopyx.core.transform.interpolation.fft", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.fft.interpolate", "modulename": "nanopyx.core.transform.interpolation.fft", "qualname": "interpolate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"n\">magnification</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.fft_zoom", "modulename": "nanopyx.core.transform.interpolation.fft_zoom", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.fft_zoom.magnify", "modulename": "nanopyx.core.transform.interpolation.fft_zoom", "qualname": "magnify", "kind": "function", "doc": "<p>Zoom an image by zero-padding its Discrete Fourier transform.</p>\n\n<p>Args:\n    image (np.ndarray): 2D grid of pixel values.\n    magnification (float): Factor by which to multiply the dimensions of the image.\n        Must be &gt;= 1.\n    enforce_same_value (bool): If True, the value of the original samples will be preserved.</p>\n\n<p>Returns:\n    np.ndarray: zoomed image.</p>\n\n<p>REF: based on <a href=\"https://github.com/centreborelli/fourier\">https://github.com/centreborelli/fourier</a>\nCredit goes to Carlo de Franchis <a href=\"&#x6d;&#x61;&#x69;l&#x74;&#x6f;&#58;&#x63;&#x61;&#x72;&#x6c;&#x6f;&#46;&#100;&#x65;-&#x66;&#x72;&#x61;&#110;&#x63;&#x68;&#105;&#115;&#x40;&#101;&#x6e;&#115;&#45;p&#97;&#x72;&#x69;&#115;&#x2d;s&#97;c&#x6c;&#x61;&#121;&#x2e;&#102;r\">&#x63;&#x61;&#x72;&#x6c;&#x6f;&#46;&#100;&#x65;-&#x66;&#x72;&#x61;&#110;&#x63;&#x68;&#105;&#115;&#x40;&#101;&#x6e;&#115;&#45;p&#97;&#x72;&#x69;&#115;&#x2d;s&#97;c&#x6c;&#x61;&#121;&#x2e;&#102;r</a></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">magnification</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">enforce_same_value</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos", "modulename": "nanopyx.core.transform.interpolation.lanczos", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos.magnify", "modulename": "nanopyx.core.transform.interpolation.lanczos", "qualname": "magnify", "kind": "function", "doc": "<p>Magnify a 2D image using the Lanczos interpolation method.</p>\n\n<p>Parameters:\n    im (np.ndarray): The 2D image to magnify.\n    magnification (int): The magnification factor.\n    taps (int): The number of taps (interpolation points) to use in the Lanczos kernel.</p>\n\n<p>Returns:\n    The magnified image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos.shift", "modulename": "nanopyx.core.transform.interpolation.lanczos", "qualname": "shift", "kind": "function", "doc": "<p>Shift a 2D image using the Lanczos interpolation method.</p>\n\n<p>Parameters:\n    im (np.ndarray): The 2D image to shift.\n    dx (float): The amount to shift the image in the x direction.\n    dy (float): The amount to shift the image in the y direction.\n    taps (int): The number of taps (interpolation points) to use in the Lanczos kernel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.translation", "modulename": "nanopyx.core.transform.translation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.translation.translate_array", "modulename": "nanopyx.core.transform.translation", "qualname": "translate_array", "kind": "function", "doc": "<p>Translate an array of images using the drift data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils", "modulename": "nanopyx.core.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.data", "modulename": "nanopyx.core.utils.data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.imagegenerator", "modulename": "nanopyx.core.utils.imagegenerator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.imagegenerator.beads", "modulename": "nanopyx.core.utils.imagegenerator.beads", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.imagegenerator.beads.generate_random_position", "modulename": "nanopyx.core.utils.imagegenerator.beads", "qualname": "generate_random_position", "kind": "function", "doc": "<p>Generates a random position given number of rows and columns.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_rows</strong>:  int; number of rows</li>\n<li><strong>n_cols</strong>:  int; number of columns</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int, int; random position constrained to 0.1 and 0.9 of n_rows and n_cols</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_rows</span>, </span><span class=\"param\"><span class=\"n\">n_cols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.imagegenerator.beads.generate_image", "modulename": "nanopyx.core.utils.imagegenerator.beads", "qualname": "generate_image", "kind": "function", "doc": "<p>Generates a random image with objects in random positions</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_objects</strong>:  int; number of objects to generate</li>\n<li><strong>shape</strong>:  tuple; with shape (z, y, x)</li>\n<li><strong>dtype</strong>:  data type to be used in the generated numpy array</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (z, y, x) and defined data type and n_objects</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_objects</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>, </span><span class=\"param\">dtype=&lt;class &#x27;numpy.float16&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.imagegenerator.beads.generate_timelapse_drift", "modulename": "nanopyx.core.utils.imagegenerator.beads", "qualname": "generate_timelapse_drift", "kind": "function", "doc": "<p>Generate random timelapse image with drift over time.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_objects</strong>:  int; number of objects to generate</li>\n<li><strong>shape</strong>:  tuple; with shape (t, y, x)</li>\n<li><strong>dtype</strong>:  data type to be used in the generated numpy array</li>\n<li><strong>drift</strong>:  None or int; number of pixels corresponding to drift between frames. If None, automatic drift is\ncalculated based on 0.02 of image dimensions.</li>\n<li><strong>drift_mode</strong>:  str; \"directional\" (default) or \"random\";</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x) and defined data type and n_objects</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_objects</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>,</span><span class=\"param\">\tdtype=&lt;class &#x27;numpy.float16&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">drift</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">drift_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;directional&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.imagegenerator.beads.generate_channel_misalignment", "modulename": "nanopyx.core.utils.imagegenerator.beads", "qualname": "generate_channel_misalignment", "kind": "function", "doc": "<p>Generates an image with shape (3, 300, 300) with 1 object centered on each 3x3 block of the image.\nSlices corresponding to channel 2 and 3 are shifted relative to channel 1.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array of shape (3, 300, 300) corresponding to a random image with misalignment between channels.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.logo", "modulename": "nanopyx.core.utils.logo", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.logo.print_ascii_logo", "modulename": "nanopyx.core.utils.logo", "qualname": "print_ascii_logo", "kind": "function", "doc": "<p>Prints the nanopyx logo. Oink! Oink!</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.time", "modulename": "nanopyx.core.utils.time", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.time.timeit", "modulename": "nanopyx.core.utils.time.timeit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.time.timeit.timeit", "modulename": "nanopyx.core.utils.time.timeit", "qualname": "timeit", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.time.timeit.timeit2", "modulename": "nanopyx.core.utils.time.timeit", "qualname": "timeit2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data", "modulename": "nanopyx.data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.examples", "modulename": "nanopyx.data.examples", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.examples.download", "modulename": "nanopyx.data.examples.download", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.__init__", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.__init__", "kind": "function", "doc": "<p>If to_download_path is None, a temporary directory will be created.\nNote that it will not be automatically deleted.\nTo clear downloads use self._clear_download()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">to_download_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.list_datasets", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.list_datasets", "kind": "function", "doc": "<p>Returns a list of dataset labels</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.list_datasets_nickname", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.list_datasets_nickname", "kind": "function", "doc": "<p>Returns a list of dataset labels</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.get_dataset_info", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.get_dataset_info", "kind": "function", "doc": "<p>Returns a dictionary with information about the dataset</p>\n\n<p>Parameters\n    dataset_name (str): can be a dataset label or nickname</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.download_zarr", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.download_zarr", "kind": "function", "doc": "<p>Downloads the zarr dataset and returns the path to the zarr file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.download_tiff_sequence", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.download_tiff_sequence", "kind": "function", "doc": "<p>Downloads the tiff sequence and returns the path to the zip file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.get_ZipTiffIterator", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.get_ZipTiffIterator", "kind": "function", "doc": "<p>Downloads the tiff sequence and returns the ZipTiffIterator</p>\n\n<p>Parameters\n    dataset_name (str): can be a dataset label or nickname\n    as_ndarray (bool): if True, returns a numpy array instead of a ZipTiffIterator</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">as_ndarray</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">nanopyx</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">zip_image_loader</span><span class=\"o\">.</span><span class=\"n\">ZipTiffIterator</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.get_thumbnail", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.get_thumbnail", "kind": "function", "doc": "<p>Returns the path to the thumbnail</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples.download.ExampleDataManager.clear_downloads", "modulename": "nanopyx.data.examples.download", "qualname": "ExampleDataManager.clear_downloads", "kind": "function", "doc": "<p>Deletes all downloaded datasets</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods", "modulename": "nanopyx.methods", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration", "modulename": "nanopyx.methods.channel_registration", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimate_channel_registration", "modulename": "nanopyx.methods.channel_registration", "qualname": "estimate_channel_registration", "kind": "function", "doc": "<p>Function used to estimate shift between different color channels and align them of an image based on cross correlation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>: numpy array  with shape (n_channels, y, x); image to be corrected</li>\n<li><strong>ref_channel</strong>:  int; channel index to be used as reference</li>\n<li><strong>max_shift</strong>:  int; maximum shift accepted for correction, in pixels.</li>\n<li><strong>blocks_per_axis</strong>:  int; number of blocks to divide the image in both x and y dimensions</li>\n<li><strong>min_similarity</strong>:  float; minimum value of similarity to accept a shift as a correction</li>\n<li><strong>method</strong>:  str; \"subpixel\" (default) or \"max\"; subpixel uses a minimizer to find the maximum correlation with\nsubpixel precision, max simply takes the maximum of the cross correlation map</li>\n<li><strong>save_translation_masks</strong>:  bool, defaults to True; whether to save translation masks as a tif or not</li>\n<li><strong>translation_mask_save_path</strong>:  str; path where to save translation masks</li>\n<li><strong>save_ccms</strong>:  bool, defaults to True; whether to save cross correlation matrices as a tif or not</li>\n<li><strong>ccms_save_path</strong>:  str; path where to save cross correlation matrices</li>\n<li><strong>apply</strong>:  bool; whether to apply the correction if True or only estimate if False</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>if apply==True, returns corrected image with shape (c, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.apply_channel_registration", "modulename": "nanopyx.methods.channel_registration", "qualname": "apply_channel_registration", "kind": "function", "doc": "<p>Function used to align different color channels of an image based on cross correlation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array with shape (n_channels, y, x); image to be registered</li>\n<li><strong>translation_masks</strong>:  numpy array of translation masks</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>returns corrected image with shape (c, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.corrector", "modulename": "nanopyx.methods.channel_registration.corrector", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.__init__", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.load_translation_masks", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.load_translation_masks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.align_channels", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.align_channels", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">img_stack</span>, </span><span class=\"param\"><span class=\"n\">translation_masks</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator", "modulename": "nanopyx.methods.channel_registration.estimator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.__init__", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.apply_elastic_transform", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.apply_elastic_transform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">img_stack</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.calculate_translation", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.calculate_translation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">channel_to_align</span>,</span><span class=\"param\">\t<span class=\"n\">ref_channel_img</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;subpixel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.save_translation_mask", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.save_translation_mask", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.save_ccms", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.save_ccms", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.estimate", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.estimate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">img_stack</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">ref_channel</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;subpixel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">save_translation_masks</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">translation_mask_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_ccms</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ccms_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">apply</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimate_drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "qualname": "estimate_drift_alignment", "kind": "function", "doc": "<p>Function use to estimate the drift in a microscopy image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array  with shape (z, y, x)</li>\n<li><strong>save_as_npy (optional)</strong>:  bool, whether to save as npy (if true) or csv (if false)</li>\n<li><strong>save_drift_table_path (optional)</strong>:  str, path to save drift table</li>\n<li><strong>roi (optional)</strong>:  in case of use should have shape (x0, y0, x1, y1)</li>\n<li><strong>kwargs</strong>:  additional keyword arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image as numpy array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.apply_drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "qualname": "apply_drift_alignment", "kind": "function", "doc": "<p>Function used to correct the drift in a microscopy image given a previously calculated drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array  with shape (z, y, x); image to be corrected</li>\n<li><strong>path (optional)</strong>:  str; path to previously saved</li>\n<li><strong>drift_table (optional)</strong>:  estimator table object; object containing previously calculated drift table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image as numpy array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.corrector", "modulename": "nanopyx.methods.drift_alignment.corrector", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector", "kind": "class", "doc": "<p>Main class for aligning timelapse images with drift.\nRequired previous calculation of a drift table.\nImplements the following methods:</p>\n\n<ul>\n<li>apply_correction</li>\n<li>load_drift_table</li>\n<li>_translate_slice</li>\n</ul>\n"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.__init__", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.apply_correction", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.apply_correction", "kind": "function", "doc": "<p>Main method of DriftCorrector class.\nTranslates each image slice according to the drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array with shape (n_slices, rows, columns)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image array with shape (n_slices, rows, columns)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.load_estimator_table", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.load_estimator_table", "kind": "function", "doc": "<p>Method used to load the drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  path to a .csv or .npy drift table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None, stores drift table data in self.drift_table</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator", "modulename": "nanopyx.methods.drift_alignment.estimator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.__init__", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.estimate", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.estimate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.compute_temporal_averaging", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.compute_temporal_averaging", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image_arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.get_shift_from_ccm_slice", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.get_shift_from_ccm_slice", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">slice_index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.get_shifts_from_ccm", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.get_shifts_from_ccm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.create_drift_table", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.create_drift_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.save_drift_table", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.save_drift_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">save_as_npy</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.set_estimator_params", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.set_estimator_params", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable", "kind": "class", "doc": "<p>Class used to store DriftAlignment parameters as a dictionary.\nParameters can be changes individually by setting the corresponding params key value to desired parameter</p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.__init__", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.set_params", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.set_params", "kind": "function", "doc": "<p>Method used to set the parameters of drift alignment using keyword arguments.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>:  same as self.params.keys()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.set_comments", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.set_comments", "kind": "function", "doc": "<p>Method used to set comments for drift alignment operation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>comment_string</strong>:  str, comment text to be added</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">comment_string</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.export_npy", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.export_npy", "kind": "function", "doc": "<p>Method used to export drift table as a npy file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  Path to export drift table as npy</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.import_npy", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.import_npy", "kind": "function", "doc": "<p>Method used to import drift table as a npy file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, Path to drift table saved as a npy file</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.export_csv", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.export_csv", "kind": "function", "doc": "<p>Method used to export drift table as a csv file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, Path to export drift table as csv</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.import_csv", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.import_csv", "kind": "function", "doc": "<p>Method used to import drift table from a csv file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, path to import drift table as csv</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.esrrf", "modulename": "nanopyx.methods.esrrf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.squirrel", "modulename": "nanopyx.methods.squirrel", "kind": "module", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();