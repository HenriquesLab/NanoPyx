window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "nanopyx", "modulename": "nanopyx", "kind": "module", "doc": "<h1 id=\"under-development-currently-in-alpha-stage\">Under Development, currently in alpha stage</h1>\n\n<p>Implementations of drift alignment and channel registration should be working, remaining features are under development and/or broken (for now)</p>\n\n<h1 id=\"nanopyx\">NanoPyx</h1>\n\n<p><a href=\"https://github.com/HenriquesLab/NanoPyx/blob/main/LICENSE.txt\"><img src=\"https://img.shields.io/pypi/l/nanopyx.svg?color=green\" alt=\"License\" /></a>\n<a href=\"https://pypi.org/project/nanopyx\"><img src=\"https://img.shields.io/pypi/v/nanopyx.svg?color=green\" alt=\"PyPI\" /></a>\n<a href=\"https://python.org\"><img src=\"https://img.shields.io/pypi/pyversions/nanopyx.svg?color=green\" alt=\"Python Version\" /></a>\n<a href=\"https://github.com/HenriquesLab/NanoPyx/actions/workflows/python-package-test.yml\"><img src=\"https://github.com/HenriquesLab/NanoPyx/actions/workflows/test_package.yml/badge.svg\" alt=\"tests\" /></a>\n<a href=\"https://codecov.io/gh/HenriquesLab/NanoPyx\"><img src=\"https://codecov.io/gh/HenriquesLab/NanoPyx/branch/main/graph/badge.svg\" alt=\"codecov\" /></a>\n<a href=\"https://pypi.org/project/nanopyx\"><img src=\"https://img.shields.io/pypi/dm/nanopyx\" alt=\"Downloads\" /></a>\n<a href=\"https://henriqueslab.github.io/NanoPyx\"><img src=\"https://img.shields.io/badge/documentation-link-blueviolet\" alt=\"Docs\" /></a></p>\n\n<p>Nanoscopy Python library (NanoPyx, the successor to NanoJ) - focused on light microscopy and super-resolution imaging</p>\n\n<hr />\n\n<h2 id=\"what-is-the-nanopyx-library\">What is the NanoPyx \ud83d\udd2c Library?</h2>\n\n<p>NanoPyx is a library specialized in the analysis of light microscopy and super-resolution data.\nIt is a successor to <a href=\"https://github.com/HenriquesLab/NanoJ-Core\">NanoJ</a>, which is a Java library for the analysis of super-resolution microscopy data.</p>\n\n<p>NanoPyx focuses on performance, by heavily exploiting cython aided multiprocessing and simplicity. It implements methods for the bioimage analysis field, with a special emphasis on those developed by the <a href=\"https://henriqueslab.github.io/\">Henriques Laboratory</a>.</p>\n\n<p>Currently it implements the following approaches:</p>\n\n<ul>\n<li>A reimplementation of the NanoJ drift correction and channel registration methods</li>\n<li>More to come soon\u2122</li>\n</ul>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>You can install <code>NanoPyx</code> via [pip]:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>nanopyx\n</code></pre>\n</div>\n\n<p>or if you want to install with all optional dependencies</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span><span class=\"s1\">&#39;nanopyx[all]&#39;</span>\n</code></pre>\n</div>\n\n<p>To install latest development version :</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>git+https://github.com/HenriquesLab/NanoPyx.git\n</code></pre>\n</div>\n\n<h3 id=\"notes-for-mac-users\">Notes for Mac users</h3>\n\n<p>If you wish to compile the NanoPyx library from source, you will need to install the following dependencies:</p>\n\n<ul>\n<li>Homebrew from <a href=\"https://brew.sh/\">https://brew.sh/</a></li>\n<li>gcc, llvm and libomp from Homebrew through the command:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>brew<span class=\"w\"> </span>install<span class=\"w\"> </span>gcc<span class=\"w\"> </span>llvm<span class=\"w\"> </span>libomp\n</code></pre>\n</div>\n\n<h2 id=\"run-in-jupyterlab-within-a-docker-container\">Run in jupyterlab within a docker container</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>docker<span class=\"w\"> </span>run<span class=\"w\"> </span>--name<span class=\"w\"> </span>nanopyx1<span class=\"w\"> </span>-p<span class=\"w\"> </span><span class=\"m\">8888</span>:8888<span class=\"w\"> </span>henriqueslab/nanopyx:latest\n</code></pre>\n</div>\n\n<h2 id=\"contributing\">Contributing</h2>\n\n<p>Contributions are very welcome. <br />\nPlease read our <a href=\"https://github.com/HenriquesLab/NanoPyx/blob/main/CONTRIBUTING.md\">Contribution Guidelines</a> to know how to proceed.</p>\n\n<h2 id=\"license\">License</h2>\n\n<p>Distributed under the terms of the [GNU GPL v2.0] license,\n\"NanoPyx\" is free and open source software</p>\n\n<h2 id=\"issues\">Issues</h2>\n\n<p>If you encounter any problems, please [file an issue] along with a detailed description.</p>\n\n<h2 id=\"development-at-a-glance\">Development at a glance</h2>\n\n<h2 id=\"repography-logohttpsimagesrepographycomlogosvghttpsrepographycom-structure\"><a href=\"https://repography.com\"><img src=\"https://images.repography.com/logo.svg\" alt=\"Repography logo\" /></a> / Structure</h2>\n\n<p><a href=\"https://github.com/HenriquesLab/NanoPyx\"><img src=\"https://images.repography.com/33651790/HenriquesLab/NanoPyx/structure/6USKh-PjgkYlbiepDRN9aThOShl3TNx_VkIycH0M6e0/Sqp8CSmE3HObh4_sa8_-IsUByYshpCVQpMuu1E_Fwiw_table.svg\" alt=\"Structure\" /></a></p>\n"}, {"fullname": "nanopyx.core", "modulename": "nanopyx.core", "kind": "module", "doc": "<p>Contains core methods to analyse and manipulate data within NanoPyx</p>\n"}, {"fullname": "nanopyx.core.analysis", "modulename": "nanopyx.core.analysis", "kind": "module", "doc": "<p>Module containing image analysis functions.\nIncludes functions for cross correlations and Pearson's correlation.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm", "modulename": "nanopyx.core.analysis.ccm", "kind": "module", "doc": "<p>Module used for creating cross correlation matrices for image stacks.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.ccm", "modulename": "nanopyx.core.analysis.ccm.ccm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.ccm.calculate_ccm", "modulename": "nanopyx.core.analysis.ccm.ccm", "qualname": "calculate_ccm", "kind": "function", "doc": "<p>Function used to generate a cross correlation matrix of an image stack.\nCross correlation is calculated using either the first image of the stack or the previous image.\nCross correlation values are normalized by the minimum and maximum Pearson's correlation between the two\nimages.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img_stack</strong>:  numpy array with shape (t, y, x)</li>\n<li><strong>ref</strong>:  either 0 or 1, 0 is used to calculate the ccm based on the first frame, 1 used to calculate based on the previous frame</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x), corresponding to the cross correlation matrix</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.ccm.calculate_ccm_from_ref", "modulename": "nanopyx.core.analysis.ccm.ccm", "qualname": "calculate_ccm_from_ref", "kind": "function", "doc": "<p>Function used to generate a cross correlation matrix of an image stack.\nCross correlation is calculated using a static image frame.\nCross correlation values are normalized by the minimum and maximum Pearson's correlation between the two\nimages.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img_stack</strong>:  numpy array with shape (t, y, x)</li>\n<li><strong>img_ref</strong>:  numpy array with shape (y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x), corresponding to the cross correlation matrix</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "modulename": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.cross_correlation_elastic.calculate_translation_mask", "modulename": "nanopyx.core.analysis.ccm.cross_correlation_elastic", "qualname": "calculate_translation_mask", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img_slice</span>,</span><span class=\"param\">\t<span class=\"n\">img_ref</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;subpixel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer", "kind": "class", "doc": "<p>Class GetMaxOptimizer, used to extract the maximum value from a cross correlation matrix with subpixel precision.</p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.__init__", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.__init__", "kind": "function", "doc": "<p>Creates an instance of GetMaxOptimizer.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice_ccm</strong>:  numpy array with shape (y, x); ccm from which to extract the maximum value with subpixel\nprecision.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">slice_ccm</span></span>)</span>"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.get_interpolated_px_value", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.get_interpolated_px_value", "kind": "function", "doc": "<p>Method to be used for calculating the interpolated values of cross correlation matrices.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coords</strong>:  tuple of coordinates.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of cross correlation matrix at given coordinates.\n  For minimizer reasons -> negatives values become positive and positive become negative.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coords</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.estimate_shift.GetMaxOptimizer.get_max", "modulename": "nanopyx.core.analysis.ccm.estimate_shift", "qualname": "GetMaxOptimizer.get_max", "kind": "function", "doc": "<p>Method used to calculate the maximum value and corresponding coordinates of a ccm. Uses a minimizer approach.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple; coordinates of maximum value of ccm with subpixel precision</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.check_even_square", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "check_even_square", "kind": "function", "doc": "<p>Function used to check if an image array is an even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool, True if an image array is an even square</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.get_closest_even_square_size", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "get_closest_even_square_size", "kind": "function", "doc": "<p>Function used to calculate the closest even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x); image to be cropped</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int; value of dimensions to be used for cropping</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.helper_functions.make_even_square", "modulename": "nanopyx.core.analysis.ccm.helper_functions", "qualname": "make_even_square", "kind": "function", "doc": "<p>Function used to crop an image array into an even square.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_arr</strong>:  numpy array with shape (t, y, x); image to be cropped</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.rcc", "modulename": "nanopyx.core.analysis.ccm.rcc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.ccm.rcc.calculate_x_corr", "modulename": "nanopyx.core.analysis.ccm.rcc", "qualname": "calculate_x_corr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">im2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.rcc.get_image_shift", "modulename": "nanopyx.core.analysis.ccm.rcc", "qualname": "get_image_shift", "kind": "function", "doc": "<p>Computes the shift from im1 to ima2</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">im2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">box</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.rcc.rcc", "modulename": "nanopyx.core.analysis.ccm.rcc", "qualname": "rcc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im_frames</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">max_shift</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.ccm.rcc.minimize_shifts", "modulename": "nanopyx.core.analysis.ccm.rcc", "qualname": "minimize_shifts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shifts_x</span>, </span><span class=\"param\"><span class=\"n\">shifts_y</span>, </span><span class=\"param\"><span class=\"n\">shifts_z</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.pearson_correlation", "modulename": "nanopyx.core.analysis.pearson_correlation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.analysis.pearson_correlation.calculate_ppmcc", "modulename": "nanopyx.core.analysis.pearson_correlation", "qualname": "calculate_ppmcc", "kind": "function", "doc": "<p>Calculates the Pearson's correlation between two images after applying a shift.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im1</strong>:  numpy array with shape (y, x)</li>\n<li><strong>im2</strong>:  numpy array with shape (y, x)</li>\n<li><strong>shift_x</strong>:  int; value to shift images in x dimension</li>\n<li><strong>shift_y</strong>:  int; value to shift images in y dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of Pearson's Correlation function after shifting the two images.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.analysis.pearson_correlation.pearson_correlation", "modulename": "nanopyx.core.analysis.pearson_correlation", "qualname": "pearson_correlation", "kind": "function", "doc": "<p>Calculates the Pearson's correlation between two images.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im1</strong>:  numpy array with shape (y, x)</li>\n<li><strong>im2</strong>:  numpy array with shape (y, x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float; value of Pearson's correlation between two images</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image", "modulename": "nanopyx.core.image", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.add_gaussians", "modulename": "nanopyx.core.image.add_gaussians", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.add_gaussians.render_random_gaussians", "modulename": "nanopyx.core.image.add_gaussians", "qualname": "render_random_gaussians", "kind": "function", "doc": "<p>Generate a stack of images with random particles</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>width</strong>:  the width of the image</li>\n<li><strong>height</strong>:  the height of the image</li>\n<li><strong>nFrames</strong>:  the number of frames in the stack</li>\n<li><strong>particles_per_slice</strong>:  the number of particles per frame</li>\n<li><strong>amplitude</strong>:  the amplitude of the particles</li>\n<li><strong>sigma_x</strong>:  the sigma of the particles in the x direction</li>\n<li><strong>sigma_y</strong>:  the sigma of the particles in the y direction</li>\n<li><strong>particles_per_slice_randomness</strong>:  the randomness of the number of particles per frame</li>\n<li><strong>amplitude_randomness</strong>:  the randomness of the amplitude of the particles</li>\n<li><strong>sigma_x_randomness</strong>:  the randomness of the sigma of the particles in the x direction</li>\n<li><strong>sigma_y_randomness</strong>:  the randomness of the sigma of the particles in the y direction</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a stack of images with random particles</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_gaussians.render_gaussians", "modulename": "nanopyx.core.image.add_gaussians", "qualname": "render_gaussians", "kind": "function", "doc": "<p>Render a set of gaussian particles on an image using the error function (erf) to calculate the integral of the gaussian</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  the image to render the particles on</li>\n<li><strong>xp</strong>:  the x position of the center of the gaussian</li>\n<li><strong>yp</strong>:  the y position of the center of the gaussian</li>\n<li><strong>amplitude</strong>:  the amplitude of the gaussian</li>\n<li><strong>sigma_x</strong>:  the sigma of the gaussian in the x direction</li>\n<li><strong>sigma_y</strong>:  the sigma of the gaussian in the y direction</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the image with the particles rendered on it</p>\n</blockquote>\n\n<p>Original implementation: <a href=\"https://github.com/HenriquesLab/NanoJ-Core/blob/80020c9cf5ecac70019daa5731d0c296cb306ac4/Core/src/nanoj/core/java/image/rendering/SubPixelGaussianRendering.java#L12\">https://github.com/HenriquesLab/NanoJ-Core/blob/80020c9cf5ecac70019daa5731d0c296cb306ac4/Core/src/nanoj/core/java/image/rendering/SubPixelGaussianRendering.java#L12</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_ramp", "modulename": "nanopyx.core.image.add_ramp", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.add_ramp.add_ramp", "modulename": "nanopyx.core.image.add_ramp", "qualname": "add_ramp", "kind": "function", "doc": "<p>Adds a ramp from vmin to vmax to the image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The image to add the ramp to</li>\n<li><strong>vmax</strong>:  The maximum intensity value of the ramp</li>\n<li><strong>vmin</strong>:  The minimum intensity value of the ramp</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_ramp.get_ramp", "modulename": "nanopyx.core.image.add_ramp", "qualname": "get_ramp", "kind": "function", "doc": "<p>Returns a 2D array of size (w, h) with a ramp from vmin to vmax</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>w</strong>:  The width of the image</li>\n<li><strong>h</strong>:  The height of the image</li>\n<li><strong>vmax</strong>:  The maximum intensity value of the ramp</li>\n<li><strong>vmin</strong>:  The minimum intensity value of the ramp</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The image with the ramp</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_random_noise", "modulename": "nanopyx.core.image.add_random_noise", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.add_random_noise.add_mixed_gaussian_poisson_noise", "modulename": "nanopyx.core.image.add_random_noise", "qualname": "add_mixed_gaussian_poisson_noise", "kind": "function", "doc": "<p>Add mixed Gaussian-Poisson noise to an image, pure cython version</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The image to add noise to, need to be 2D or 3D</li>\n<li><strong>gauss_sigma</strong>:  The standard deviation of the Gaussian noise</li>\n<li><strong>gauss_mean</strong>:  The mean of the Gaussian noise</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_random_noise.add_mixed_gaussian_poisson_noise2", "modulename": "nanopyx.core.image.add_random_noise", "qualname": "add_mixed_gaussian_poisson_noise2", "kind": "function", "doc": "<p>Add mixed Gaussian-Poisson noise to an image, pure numpy version</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The image to add noise to</li>\n<li><strong>gauss_sigma</strong>:  The standard deviation of the Gaussian noise</li>\n<li><strong>gauss_mean</strong>:  The mean of the Gaussian noise</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_random_noise.add_perlin_noise", "modulename": "nanopyx.core.image.add_random_noise", "qualname": "add_perlin_noise", "kind": "function", "doc": "<p>Add perlin noise to an image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The image to add noise to</li>\n<li><strong>amp</strong>:  The amplitude of the noise</li>\n<li><strong>offset</strong>:  The offset of the noise</li>\n<li><strong>f</strong>:  The frequency of the noise</li>\n<li><strong>octaves</strong>:  The number of octaves</li>\n<li><strong>persistence</strong>:  The persistence of the noise</li>\n<li><strong>lacunarity</strong>:  The lacunarity of the noise</li>\n<li><strong>repeatx</strong>:  The repeat of the noise in the x direction</li>\n<li><strong>repeaty</strong>:  The repeat of the noise in the y direction</li>\n<li><strong>base</strong>:  The base of the noise</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_random_noise.get_perlin_noise", "modulename": "nanopyx.core.image.add_random_noise", "qualname": "get_perlin_noise", "kind": "function", "doc": "<p>Return a perlin noise image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>w</strong>:  The width of the image</li>\n<li><strong>h</strong>:  The height of the image</li>\n<li><strong>amp</strong>:  The amplitude of the noise</li>\n<li><strong>offset</strong>:  The offset of the noise</li>\n<li><strong>f</strong>:  The frequency of the noise</li>\n<li><strong>octaves</strong>:  The number of octaves</li>\n<li><strong>persistence</strong>:  The persistence of the noise</li>\n<li><strong>lacunarity</strong>:  The lacunarity of the noise</li>\n<li><strong>repeatx</strong>:  The repeat of the noise in the x direction</li>\n<li><strong>repeaty</strong>:  The repeat of the noise in the y direction</li>\n<li><strong>base</strong>:  The base of the noise</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The perlin noise image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_random_noise.get_simplex_noise", "modulename": "nanopyx.core.image.add_random_noise", "qualname": "get_simplex_noise", "kind": "function", "doc": "<p>Return a simplex noise image\nREF: <a href=\"https://github.com/lmas/opensimplex\">https://github.com/lmas/opensimplex</a></p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>w</strong>:  The width of the image</li>\n<li><strong>h</strong>:  The height of the image</li>\n<li><strong>f</strong>:  The frequency of the noise</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The simplex noise image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_squares", "modulename": "nanopyx.core.image.add_squares", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.add_squares.add_squares", "modulename": "nanopyx.core.image.add_squares", "qualname": "add_squares", "kind": "function", "doc": "<p>Add random squares to an image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The image to add the squares to</li>\n<li><strong>vmax</strong>:  The maximum intensity value of the squares</li>\n<li><strong>vmin</strong>:  The minimum intensity value of the squares</li>\n<li><strong>nSquares</strong>:  The number of squares to add</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.add_squares.get_squares", "modulename": "nanopyx.core.image.add_squares", "qualname": "get_squares", "kind": "function", "doc": "<p>Return an image with random squares</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>w</strong>:  The width of the image</li>\n<li><strong>h</strong>:  The height of the image</li>\n<li><strong>vmax</strong>:  The maximum intensity value of the squares</li>\n<li><strong>vmin</strong>:  The minimum intensity value of the squares</li>\n<li><strong>nSquares</strong>:  The number of squares to add</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The image with random squares</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">im_squares</span> <span class=\"o\">=</span> <span class=\"n\">get_squares</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">im_squares</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(100, 100)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.blocks", "modulename": "nanopyx.core.image.blocks", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.blocks.assemble_frame_from_blocks", "modulename": "nanopyx.core.image.blocks", "qualname": "assemble_frame_from_blocks", "kind": "function", "doc": "<p>Function used to assemble a full image from blocks</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>blocks_stack</strong>:  numpy array with shape (n_blocks, y, x)</li>\n<li><strong>n_blocks_height</strong>:  int; number of blocks in y</li>\n<li><strong>n_blocks_width</strong>:  int; number of blocks in x</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (y<em>n_blocks, x</em>n_blocks)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">blocks_stack</span>, </span><span class=\"param\"><span class=\"n\">n_blocks_height</span>, </span><span class=\"param\"><span class=\"n\">n_blocks_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.generate", "modulename": "nanopyx.core.image.generate", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.generate.beads", "modulename": "nanopyx.core.image.generate.beads", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.image.generate.beads.generate_random_position", "modulename": "nanopyx.core.image.generate.beads", "qualname": "generate_random_position", "kind": "function", "doc": "<p>Generates a random position given number of rows and columns.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_rows</strong>:  int; number of rows</li>\n<li><strong>n_cols</strong>:  int; number of columns</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int, int; random position constrained to 0.1 and 0.9 of n_rows and n_cols</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_rows</span>, </span><span class=\"param\"><span class=\"n\">n_cols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.generate.beads.generate_image", "modulename": "nanopyx.core.image.generate.beads", "qualname": "generate_image", "kind": "function", "doc": "<p>Generates a random image with objects in random positions</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_objects</strong>:  int; number of objects to generate</li>\n<li><strong>shape</strong>:  tuple; with shape (z, y, x)</li>\n<li><strong>dtype</strong>:  data type to be used in the generated numpy array</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (z, y, x) and defined data type and n_objects</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_objects</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>, </span><span class=\"param\">dtype=&lt;class &#x27;numpy.float16&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.generate.beads.generate_timelapse_drift", "modulename": "nanopyx.core.image.generate.beads", "qualname": "generate_timelapse_drift", "kind": "function", "doc": "<p>Generate random timelapse image with drift over time.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_objects</strong>:  int; number of objects to generate</li>\n<li><strong>shape</strong>:  tuple; with shape (t, y, x)</li>\n<li><strong>dtype</strong>:  data type to be used in the generated numpy array</li>\n<li><strong>drift</strong>:  None or int; number of pixels corresponding to drift between frames. If None, automatic drift is\ncalculated based on 0.02 of image dimensions.</li>\n<li><strong>drift_mode</strong>:  str; \"directional\" (default) or \"random\";</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array with shape (t, y, x) and defined data type and n_objects</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_objects</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>,</span><span class=\"param\">\tdtype=&lt;class &#x27;numpy.float16&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">drift</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">drift_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;directional&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.image.generate.beads.generate_channel_misalignment", "modulename": "nanopyx.core.image.generate.beads", "qualname": "generate_channel_misalignment", "kind": "function", "doc": "<p>Generates an image with shape (3, 300, 300) with 1 object centered on each 3x3 block of the image.\nSlices corresponding to channel 2 and 3 are shifted relative to channel 1.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numpy array of shape (3, 300, 300) corresponding to a random image with misalignment between channels.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io", "modulename": "nanopyx.core.io", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.checksum", "modulename": "nanopyx.core.io.checksum", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.checksum.get_checksum", "modulename": "nanopyx.core.io.checksum", "qualname": "get_checksum", "kind": "function", "doc": "<p>Returns the SHA-256 checksum of the file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  path to the file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>checksum in hexadecimal format</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.unique_names", "modulename": "nanopyx.core.io.unique_names", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.unique_names.intToRoman", "modulename": "nanopyx.core.io.unique_names", "qualname": "intToRoman", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.unique_names.get_unique_name", "modulename": "nanopyx.core.io.unique_names", "qualname": "get_unique_name", "kind": "function", "doc": "<p>Get a unique name from the list of names.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">get_unique_name</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader", "modulename": "nanopyx.core.io.zip_image_loader", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.__init__", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.__init__", "kind": "function", "doc": "<p>Iterator to sequentially open tiff files contained in a zip file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>zip_file_path</strong>:  path to the zip file</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_shape", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_shape", "kind": "function", "doc": "<p>Returns the shape of the image stack</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>shape of the image stack</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_dtype", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_dtype", "kind": "function", "doc": "<p>Returns the data type of the image stack</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data type of the image stack</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.get_thumb", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.get_thumb", "kind": "function", "doc": "<p>Saves a thumbnail (first frame) of the image stack</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>save_path</strong>:  path to save the thumbnail</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.io.zip_image_loader.ZipTiffIterator.close", "modulename": "nanopyx.core.io.zip_image_loader", "qualname": "ZipTiffIterator.close", "kind": "function", "doc": "<p>Closes the zip file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.kernels", "modulename": "nanopyx.core.kernels", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.particles", "modulename": "nanopyx.core.particles", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.particles.simulate_particle_field", "modulename": "nanopyx.core.particles.simulate_particle_field", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.particles.simulate_particle_field.simulate_particle_field_based_on_2D_PDF", "modulename": "nanopyx.core.particles.simulate_particle_field", "qualname": "simulate_particle_field_based_on_2D_PDF", "kind": "function", "doc": "<p>Simulate a particle field based on a 2D probability density function (PDF)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_pdf</strong>:  2D array of floats, the PDF</li>\n<li><strong>min_particles</strong>:  int, the minimum number of particles to simulate</li>\n<li><strong>max_particles</strong>:  int, the maximum number of particles to simulate</li>\n<li><strong>min_distance</strong>:  float, ensure that paricle distances are above minimum distance given</li>\n<li><strong>mean_distance_threshold</strong>:  float, the mean distance between closest particles, if the mean distance is below this threshold, the simulation will stop</li>\n<li><strong>max_tries</strong>:  int, the maximum number of tries to place particles before giving up</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(2D array of floats, mean closest distance), for the first tupple element the shape is (n_particles, 2) where the last dimension is the x and y coordinates of the simulated particle</p>\n</blockquote>\n\n<p>The code does the following:</p>\n\n<ol>\n<li>It samples the image PDF and places a particle at a point with a probability that is proportional to the PDF at that point.</li>\n<li>It places the particles such that no two particles are closer than <code>min_distance</code> pixels.</li>\n<li>It stops placing particles once the mean distance between all particles is less than <code>mean_distance_threshold</code> pixels.</li>\n</ol>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">image_pdf</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">((</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">particles</span> <span class=\"o\">=</span> <span class=\"n\">simulate_particle_field_based_on_2D_PDF</span><span class=\"p\">(</span><span class=\"n\">image_pdf</span><span class=\"p\">,</span> <span class=\"n\">min_particles</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">mean_distance_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.particles.simulate_particle_field.get_closest_distance", "modulename": "nanopyx.core.particles.simulate_particle_field", "qualname": "get_closest_distance", "kind": "function", "doc": "<p>Get the closest distance between all particles</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>particle_field</strong>:  2D array of floats, the particle field</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>double, the closest distance between all particles</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.particles.simulate_particle_field.render_particle_histogram", "modulename": "nanopyx.core.particles.simulate_particle_field", "qualname": "render_particle_histogram", "kind": "function", "doc": "<p>Render a particle field as an image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>particle_field</strong>:  2D array of floats, the particle field with shape (n_particles, 2) where the last dimension is the x and y coordinates of the particle</li>\n<li><strong>w</strong>:  int, the width of the image</li>\n<li><strong>h</strong>:  int, the height of the image</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>2D array of floats, the rendered particle field</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.particles.simulate_particle_field.render_particle_histogram_with_tracks", "modulename": "nanopyx.core.particles.simulate_particle_field", "qualname": "render_particle_histogram_with_tracks", "kind": "function", "doc": "<p>Render a particle field as an image stack</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>particle_field</strong>:  2D array of floats, the particle field</li>\n<li><strong>states</strong>:  2D array of ints, the states of the particles</li>\n<li><strong>w</strong>:  int, the width of the stack (in pixels)</li>\n<li><strong>h</strong>:  int, the height of the stack (in pixels)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>3D array of floats, the rendered particle field</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.particles.simulate_particle_field.render_particle_gaussians_with_tracks", "modulename": "nanopyx.core.particles.simulate_particle_field", "qualname": "render_particle_gaussians_with_tracks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.particles.simulate_photoswitching_time_tracks", "modulename": "nanopyx.core.particles.simulate_photoswitching_time_tracks", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.particles.simulate_photoswitching_time_tracks.simple_state_transition_model", "modulename": "nanopyx.core.particles.simulate_photoswitching_time_tracks", "qualname": "simple_state_transition_model", "kind": "function", "doc": "<p>Simple photoswitching state transition model</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_particles</strong>:  number of particles</li>\n<li><strong>n_ticks</strong>:  number of time ticks</li>\n<li><strong>p_on</strong>:  probability of switching on</li>\n<li><strong>p_transient_off</strong>:  probability of switching off transiently</li>\n<li><strong>p_permanent_off</strong>:  probability of switching off permanently</li>\n<li><strong>initial_state</strong>:  initial state of the photoswitch</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>array of states with shape (n_particles, n_ticks)</p>\n</blockquote>\n\n<p>States: \n    -1: bleached\n    0: off\n    1: on\nTransitions:\n    -1 -> -1\n    0 -> 0\n    1 -> 1\n    0 -> 1 with probability p_on\n    1 -> 0 with probability p_transient_off\n    1 -> -1 with probability p_permanent_off  </p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>n_ticks = 1000\n      n_particles = 100\n      p_on = 0.1\n      p_transient_off = 0.8\n      p_permanent_off = 0.1\n      initial_state = 0\n      states = simple_state_transition_model(n_ticks, n_particles, p_on, p_transient_off, p_permanent_off, initial_state)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr", "modulename": "nanopyx.core.sr", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.decorr", "modulename": "nanopyx.core.sr.decorr", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map", "modulename": "nanopyx.core.sr.error_map", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.__init__", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.optimise", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.optimise", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">fixedSigma</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.getRSE", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.getRSE", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.getRSP", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.getRSP", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.ErrorMap.get_sigma", "modulename": "nanopyx.core.sr.error_map", "qualname": "ErrorMap.get_sigma", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.calculate_alpha_beta", "modulename": "nanopyx.core.sr.error_map", "qualname": "calculate_alpha_beta", "kind": "function", "doc": "<p>Gaussian blurs imSR image and calculates linear regressino again imRef</p>\n\n<p>Args:\n    sigma (float): gaussian blur sigma\n    imRef (np.ndarray): reference image (generally a difraction limited equivalent)\n    imSR (np.ndarray): super-resolution image</p>\n\n<p>Returns:\n    tuple[float, float]: alpha and beta for linear regression</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.error_map.sigma_function_to_optimize", "modulename": "nanopyx.core.sr.error_map", "qualname": "sigma_function_to_optimize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">imRef</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">imSR</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.esrrf", "modulename": "nanopyx.core.sr.esrrf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.esrrf.CalculateRGC", "modulename": "nanopyx.core.sr.esrrf", "qualname": "CalculateRGC", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.esrrf.CalculateRGC.__init__", "modulename": "nanopyx.core.sr.esrrf", "qualname": "CalculateRGC.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "nanopyx.core.sr.esrrf.CalculateRGC.calculate", "modulename": "nanopyx.core.sr.esrrf", "qualname": "CalculateRGC.calculate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc", "modulename": "nanopyx.core.sr.frc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.frc.ThresholdMethod", "modulename": "nanopyx.core.sr.frc", "qualname": "ThresholdMethod", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.frc.ThresholdMethod.__init__", "modulename": "nanopyx.core.sr.frc", "qualname": "ThresholdMethod.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.sr.frc.pad", "modulename": "nanopyx.core.sr.frc", "qualname": "pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_frc_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_frc_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span>, </span><span class=\"param\"><span class=\"n\">im2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_smoothed_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "get_smoothed_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_threshold_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_threshold_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_intersections", "modulename": "nanopyx.core.sr.frc", "qualname": "get_intersections", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">threshold_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_correct_intersection", "modulename": "nanopyx.core.sr.frc", "qualname": "get_correct_intersection", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">intersections</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_square_tapered_image", "modulename": "nanopyx.core.sr.frc", "qualname": "get_square_tapered_image", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_window_function", "modulename": "nanopyx.core.sr.frc", "qualname": "get_window_function", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">taper</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.get_interpolated_values", "modulename": "nanopyx.core.sr.frc", "qualname": "get_interpolated_values", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">images</span>, </span><span class=\"param\"><span class=\"n\">maxx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_fire_number_from_FRC_curve", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_fire_number_from_FRC_curve", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.calculate_fire_number", "modulename": "nanopyx.core.sr.frc", "qualname": "calculate_fire_number", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">im1</span>, </span><span class=\"param\"><span class=\"n\">im2</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.frc.do_plot", "modulename": "nanopyx.core.sr.frc", "qualname": "do_plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frc_curve</span>, </span><span class=\"param\"><span class=\"n\">smooth_frc</span>, </span><span class=\"param\"><span class=\"n\">tm</span>, </span><span class=\"param\"><span class=\"n\">fire</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.sr.radial_gradient_convergence", "modulename": "nanopyx.core.sr.radial_gradient_convergence", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.radial_gradient_convergence.RadialGradientConvergence", "modulename": "nanopyx.core.sr.radial_gradient_convergence", "qualname": "RadialGradientConvergence", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.sr.radial_gradient_convergence.RadialGradientConvergence.__init__", "modulename": "nanopyx.core.sr.radial_gradient_convergence", "qualname": "RadialGradientConvergence.__init__", "kind": "function", "doc": "<p>Calculate the Radial Gradient Convergence (RGC) of an image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>magnification</strong>:  magnification of the image</li>\n<li><strong>radius</strong>:  radius of the RGC (the PSF Full-Width-Half-Maximum)</li>\n<li><strong>sensitivity</strong>:  sensitivity of the RGC (sharpening factor)</li>\n<li><strong>doIntensityWeighting</strong>:  whether to do intensity weighting</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.sr.radial_gradient_convergence.RadialGradientConvergence.calculate", "modulename": "nanopyx.core.sr.radial_gradient_convergence", "qualname": "RadialGradientConvergence.calculate", "kind": "function", "doc": "<p>Calculate the RGC of an image-stack.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im</strong>:  the image to calculate the RGC of</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the RGC of the image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform", "modulename": "nanopyx.core.transform", "kind": "module", "doc": "<p>Transforms images, for example, zooming, shifting, ...</p>\n"}, {"fullname": "nanopyx.core.transform.binning", "modulename": "nanopyx.core.transform.binning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.binning.rebin_2d", "modulename": "nanopyx.core.transform.binning", "qualname": "rebin_2d", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr: numpy array with any shape as long as last two dimensions are y, x (example</strong>:  time, channel, z, y, x)</li>\n<li><strong>bin_factor</strong>:  factor used to bin dimensions</li>\n<li><strong>mode</strong>:  can be either sum, mean or max, defaults to sum if not specified or not valid mode</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>binned array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">bin_factor</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;sum&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify", "modulename": "nanopyx.core.transform.image_magnify", "kind": "module", "doc": "<p>Combination of functions for zooming an image, using several interpolation methods.</p>\n"}, {"fullname": "nanopyx.core.transform.image_magnify.fourier_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "fourier_zoom", "kind": "function", "doc": "<p>Zoom an image by zero-padding its Discrete Fourier transform.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.catmull_rom_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "catmull_rom_zoom", "kind": "function", "doc": "<p>Zoom an image by Catmull-Rom interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.\n  REF: based on <a href=\"https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java\">https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java</a></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.catmull_rom_zoom_xy", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "catmull_rom_zoom_xy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">magnification_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">magnification_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.lanczos_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "lanczos_zoom", "kind": "function", "doc": "<p>Zoom an image by Lanczos interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n<li><strong>taps</strong>:  The number of taps (interpolation points) to use in the Lanczos kernel.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.bicubic_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "bicubic_zoom", "kind": "function", "doc": "<p>Zoom an image by bicubic interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.bilinear_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "bilinear_zoom", "kind": "function", "doc": "<p>Zoom an image by bilinear interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.nearest_neighbor_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "nearest_neighbor_zoom", "kind": "function", "doc": "<p>Zoom an image by nearest neighbor interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.scipy_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "scipy_zoom", "kind": "function", "doc": "<p>Zoom an image by SciPy interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.skimage_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "skimage_zoom", "kind": "function", "doc": "<p>Zoom an image by scikit-image interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_magnify.cv2_zoom", "modulename": "nanopyx.core.transform.image_magnify", "qualname": "cv2_zoom", "kind": "function", "doc": "<p>Zoom an image by OpenCV interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values.</li>\n<li><strong>magnification</strong>:  Factor by which to multiply the dimensions of the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.image_shift", "modulename": "nanopyx.core.transform.image_shift", "kind": "module", "doc": "<p>Combination of functions for shifting an image, using several interpolation methods.</p>\n"}, {"fullname": "nanopyx.core.transform.interpolation", "modulename": "nanopyx.core.transform.interpolation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.bicubic", "modulename": "nanopyx.core.transform.interpolation.bicubic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.bicubic.Interpolator", "modulename": "nanopyx.core.transform.interpolation.bicubic", "qualname": "Interpolator", "kind": "class", "doc": "<p></p>\n", "bases": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator"}, {"fullname": "nanopyx.core.transform.interpolation.bilinear", "modulename": "nanopyx.core.transform.interpolation.bilinear", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.bilinear.Interpolator", "modulename": "nanopyx.core.transform.interpolation.bilinear", "qualname": "Interpolator", "kind": "class", "doc": "<p></p>\n", "bases": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom.Interpolator", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "qualname": "Interpolator", "kind": "class", "doc": "<p></p>\n", "bases": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator"}, {"fullname": "nanopyx.core.transform.interpolation.catmull_rom.interpolate", "modulename": "nanopyx.core.transform.interpolation.catmull_rom", "qualname": "interpolate", "kind": "function", "doc": "<p>Interpolate image using Catmull-Rom interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im</strong>:  image to interpolate</li>\n<li><strong>x</strong>:  x-coordinate to interpolate at</li>\n<li><strong>y</strong>:  y-coordinate to interpolate at</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Interpolated pixel value (float)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.fft_zoom", "modulename": "nanopyx.core.transform.interpolation.fft_zoom", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.fft_zoom.magnify", "modulename": "nanopyx.core.transform.interpolation.fft_zoom", "qualname": "magnify", "kind": "function", "doc": "<p>Zoom an image by zero-padding its Discrete Fourier transform</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D grid of pixel values</li>\n<li><strong>magnification</strong>:  factor by which to multiply the dimensions of the image</li>\n<li><strong>enforce_same_value</strong>:  if True, the value of the original samples will be preserved</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>zoomed image</p>\n</blockquote>\n\n<p>REF: based on <a href=\"https://github.com/centreborelli/fourier\">https://github.com/centreborelli/fourier</a></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">magnification</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">enforce_same_value</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos", "modulename": "nanopyx.core.transform.interpolation.lanczos", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos.Interpolator", "modulename": "nanopyx.core.transform.interpolation.lanczos", "qualname": "Interpolator", "kind": "class", "doc": "<p></p>\n", "bases": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator"}, {"fullname": "nanopyx.core.transform.interpolation.lanczos.Interpolator.__init__", "modulename": "nanopyx.core.transform.interpolation.lanczos", "qualname": "Interpolator.__init__", "kind": "function", "doc": "<p>Interpolate the value of a 2D image at the given coordinates using the Lanczos interpolation method</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  The 2D image to interpolate</li>\n<li><strong>taps</strong>:  The number of taps (interpolation points) to use in the Lanczos kernel</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "qualname": "Interpolator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator.__init__", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "qualname": "Interpolator.__init__", "kind": "function", "doc": "<p>Interpolate a 2D array</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong>:  2D array to interpolate</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator.magnify", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "qualname": "Interpolator.magnify", "kind": "function", "doc": "<p>Magnify an image by a factor of magnification</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>magnification</strong>:  magnification factor</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>magnified image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator.magnify_xy", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "qualname": "Interpolator.magnify_xy", "kind": "function", "doc": "<p>Magnify an image by a factor of magnification</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>magnification</strong>:  magnification factor</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>magnified image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.interpolation.nearest_neighbor.Interpolator.shift", "modulename": "nanopyx.core.transform.interpolation.nearest_neighbor", "qualname": "Interpolator.shift", "kind": "function", "doc": "<p>Shift an image by (dx, dy) using interpolation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dx</strong>:  shift along x-axis</li>\n<li><strong>dy</strong>:  shift along y-axis</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>shifted image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.radiality", "modulename": "nanopyx.core.transform.radiality", "kind": "module", "doc": "<p>Python reimplementation of the Radiality Transform from the original SRRF paper\nPaper: <a href=\"https://www.nature.com/articles/ncomms12471\">https://www.nature.com/articles/ncomms12471</a>\nOriginal code: <a href=\"https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java\">https://github.com/HenriquesLab/NanoJ-SRRF/blob/master/SRRF/src/nanoj/srrf/java/SRRF.java</a></p>\n"}, {"fullname": "nanopyx.core.transform.radiality.Radiality", "modulename": "nanopyx.core.transform.radiality", "qualname": "Radiality", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.radiality.Radiality.__init__", "modulename": "nanopyx.core.transform.radiality", "qualname": "Radiality.__init__", "kind": "function", "doc": "<p>Calculate Radiality, as defined on the original version of SRRF - REF: <a href=\"https://www.nature.com/articles/ncomms12471\">https://www.nature.com/articles/ncomms12471</a></p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>magnification</strong>:  Desired magnification for the generated radiality image</li>\n<li><strong>ringRadius</strong>:  Radius of the ring used to calculate the radiality</li>\n<li><strong>border</strong>:  Number of pixels to be zeroed on the borders of the radiality image</li>\n<li><strong>radialityPositivityConstraint</strong>:  If True, the radiality image will be constrained to be positive (values &gt;= 0)</li>\n<li><strong>doIntensityWeighting</strong>:  If True, the radiality image will be weighted by the intensity of the original image</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.core.transform.radiality.Radiality.calculate", "modulename": "nanopyx.core.transform.radiality", "qualname": "Radiality.calculate", "kind": "function", "doc": "<p>Calculate Radiality, as defined on the original version of SRRF - REF: <a href=\"https://www.nature.com/articles/ncomms12471\">https://www.nature.com/articles/ncomms12471</a></p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_stack</strong>:  Image stack to be processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Radiality image-stack, magnified image-stack, x-gradient image, y-gradient image</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.transform.translation", "modulename": "nanopyx.core.transform.translation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.transform.translation.translate_array", "modulename": "nanopyx.core.transform.translation", "qualname": "translate_array", "kind": "function", "doc": "<p>Translate an array of images using the drift data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils", "modulename": "nanopyx.core.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.easy_gui", "modulename": "nanopyx.core.utils.easy_gui", "kind": "module", "doc": "<p>A module to help simplify the create of GUIs in Jupyter notebooks using ipywidgets.</p>\n"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.__init__", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.__init__", "kind": "function", "doc": "<p>Container for widgets.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>width</strong>:  width of the widget container</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;basic_gui&#39;</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"s1\">&#39;50%&#39;</span></span>)</span>"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_label", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_label", "kind": "function", "doc": "<p>Add a label widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_button", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_button", "kind": "function", "doc": "<p>Add a button widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_text", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_text", "kind": "function", "doc": "<p>Add a text widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_int_slider", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_int_slider", "kind": "function", "doc": "<p>Add a integer slider widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>remember_value</strong>:  remember the last value</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">remember_value</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_float_slider", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_float_slider", "kind": "function", "doc": "<p>Add a float slider widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>remember_value</strong>:  remember the last value</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">remember_value</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_checkbox", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_checkbox", "kind": "function", "doc": "<p>Add a checkbox widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>remember_value</strong>:  remember the last value</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">remember_value</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_int_text", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_int_text", "kind": "function", "doc": "<p>Add a integer text widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>remember_value</strong>:  remember the last value</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">remember_value</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_dropdown", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_dropdown", "kind": "function", "doc": "<p>Add a dropdown widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>remember_value</strong>:  remember the last value</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">remember_value</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.add_file_upload", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.add_file_upload", "kind": "function", "doc": "<p>Add a file upload widget to the container.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tag</strong>:  tag to identify the widget</li>\n<li><strong>args</strong>:  args for the widget</li>\n<li><strong>accept</strong>:  file types to accept</li>\n<li><strong>multiple</strong>:  allow multiple files to be uploaded</li>\n<li><strong>kwargs</strong>:  kwargs for the widget</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tag</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">accept</span><span class=\"o\">=</span><span class=\"s1\">&#39;image/*&#39;</span>, </span><span class=\"param\"><span class=\"n\">multiple</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.save_settings", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.save_settings", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.show", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.show", "kind": "function", "doc": "<p>Show the widgets in the container.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.easy_gui.EasyGui.clear", "modulename": "nanopyx.core.utils.easy_gui", "qualname": "EasyGui.clear", "kind": "function", "doc": "<p>Clear the widgets in the container.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.find_files", "modulename": "nanopyx.core.utils.find_files", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.find_files.find_files", "modulename": "nanopyx.core.utils.find_files", "qualname": "find_files", "kind": "function", "doc": "<p>Returns a list of files with given extension in the root directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">root_dir</span>, </span><span class=\"param\"><span class=\"n\">extension</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.random", "modulename": "nanopyx.core.utils.random", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.random.random", "modulename": "nanopyx.core.utils.random", "qualname": "random", "kind": "function", "doc": "<p>Returns a random value between 0 and 1.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unknown</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.time", "modulename": "nanopyx.core.utils.time", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.time.timeit", "modulename": "nanopyx.core.utils.time.timeit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.time.timeit.timeit", "modulename": "nanopyx.core.utils.time.timeit", "qualname": "timeit", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.time.timeit.timeit2", "modulename": "nanopyx.core.utils.time.timeit", "qualname": "timeit2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.toot", "modulename": "nanopyx.core.utils.toot", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.toot.toot", "modulename": "nanopyx.core.utils.toot", "qualname": "toot", "kind": "function", "doc": "<p>Post a toot to Mastodon</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>msg</strong>:  The message to post</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.core.utils.url_checker", "modulename": "nanopyx.core.utils.url_checker", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.core.utils.url_checker.url_checker", "modulename": "nanopyx.core.utils.url_checker", "qualname": "url_checker", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">url</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data", "modulename": "nanopyx.data", "kind": "module", "doc": "<p>Contains helper methods for downloading and loading example test data</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">nanopyx.data.download</span> <span class=\"kn\">import</span> <span class=\"n\">ExampleDataManager</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">downloader</span> <span class=\"o\">=</span> <span class=\"n\">ExampleDataManager</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">datasets</span> <span class=\"o\">=</span> <span class=\"n\">downloader</span><span class=\"o\">.</span><span class=\"n\">list_datasets</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;</span><span class=\"se\">\\n</span><span class=\"s2\">&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"s2\">&quot; - &quot;</span><span class=\"o\">+</span><span class=\"n\">dataset</span> <span class=\"k\">for</span> <span class=\"n\">dataset</span> <span class=\"ow\">in</span> <span class=\"n\">datasets</span><span class=\"p\">]))</span>\n<span class=\"go\"> - EMBL_TubulinGFP</span>\n<span class=\"go\"> - ImmunoSynapseFormation_LifeActGFP</span>\n<span class=\"go\"> - LongContinuous_UtrGFP</span>\n<span class=\"go\"> - PumpyCost7_UtrGFP</span>\n<span class=\"go\"> - SMLMS2013_HDTubulinAlexa647</span>\n<span class=\"go\"> - SM_U2OS_Pereira_MTAlexaA647_V1</span>\n<span class=\"go\"> - SM_U2OS_Pereira_MTAlexaA647_V2</span>\n<span class=\"go\"> - ShortContinuous_UtrGFP</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">thumbnail_path</span> <span class=\"o\">=</span> <span class=\"n\">downloader</span><span class=\"o\">.</span><span class=\"n\">get_thumbnail</span><span class=\"p\">(</span><span class=\"s2\">&quot;LongContinuous_UtrGFP&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s2\">&quot;/&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"s2\">&quot;...&quot;</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">thumbnail_path</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span><span class=\"p\">)[</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">:])</span>\n<span class=\"go\">&#39;.../nanopyx/data/examples/LongContinuous_UtrGFP/thumbnail.jpg&#39;</span>\n</code></pre>\n</div>\n"}, {"fullname": "nanopyx.data.download", "modulename": "nanopyx.data.download", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.download.ExampleDataManager", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.data.download.ExampleDataManager.__init__", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.__init__", "kind": "function", "doc": "<p>Helper class for downloading example test data</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>to_download_path</strong>:  path to download the data to. If to_download_path is None, a temporary directory will be created. Note that it will not be automatically deleted.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>:  If to_download_path is not None and does not exist</li>\n</ul>\n\n<p>To clear downloads use self._clear_download()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">to_download_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "nanopyx.data.download.ExampleDataManager.list_datasets", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.list_datasets", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of dataset labels</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.list_datasets_nickname", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.list_datasets_nickname", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of dataset nicknames</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.get_dataset_info", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.get_dataset_info", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset_name</strong>:  can be a dataset label or nickname</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dictionary with information about the dataset</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.download_tiff_sequence", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.download_tiff_sequence", "kind": "function", "doc": "<p>Downloads the tiff sequence and returns the path to the zip file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset_name</strong>:  can be a dataset label or nickname</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>path to the zip file</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.get_ZipTiffIterator", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.get_ZipTiffIterator", "kind": "function", "doc": "<p>Downloads the tiff sequence and returns the ZipTiffIterator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset_name</strong>:  can be a dataset label or nickname</li>\n<li><strong>as_ndarray</strong>:  if True, returns a numpy array instead of a ZipTiffIterator</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ZipTiffIterator or numpy array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">as_ndarray</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">nanopyx</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">zip_image_loader</span><span class=\"o\">.</span><span class=\"n\">ZipTiffIterator</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.get_thumbnail", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.get_thumbnail", "kind": "function", "doc": "<p>Returns the path to the thumbnail</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset_name</strong>:  can be a dataset label or nickname</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>path to the thumbnail</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dataset_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.download.ExampleDataManager.clear_downloads", "modulename": "nanopyx.data.download", "qualname": "ExampleDataManager.clear_downloads", "kind": "function", "doc": "<p>Deletes all downloaded datasets</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.data.examples", "modulename": "nanopyx.data.examples", "kind": "module", "doc": "<p>Placeholder for containing the example test data. Within this package folder is the metadata information for each test dataset\nSee <code>nanopyx.data.download</code> for tools to download the example data</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">os</span><span class=\"o\">,</span> <span class=\"nn\">glob</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">get_path</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s2\">&quot;/&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span><span class=\"p\">)[</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">:])</span>\n<span class=\"go\">&#39;nanopyx/data/examples&#39;</span>\n</code></pre>\n</div>\n"}, {"fullname": "nanopyx.data.examples.get_path", "modulename": "nanopyx.data.examples", "qualname": "get_path", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>path to the examples info directory</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods", "modulename": "nanopyx.methods", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration", "modulename": "nanopyx.methods.channel_registration", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimate_channel_registration", "modulename": "nanopyx.methods.channel_registration", "qualname": "estimate_channel_registration", "kind": "function", "doc": "<p>Function used to estimate shift between different color channels and align them of an image based on cross correlation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>: numpy array  with shape (n_channels, y, x); image to be corrected</li>\n<li><strong>ref_channel</strong>:  int; channel index to be used as reference</li>\n<li><strong>max_shift</strong>:  int; maximum shift accepted for correction, in pixels.</li>\n<li><strong>blocks_per_axis</strong>:  int; number of blocks to divide the image in both x and y dimensions</li>\n<li><strong>min_similarity</strong>:  float; minimum value of similarity to accept a shift as a correction</li>\n<li><strong>method</strong>:  str; \"subpixel\" (default) or \"max\"; subpixel uses a minimizer to find the maximum correlation with\nsubpixel precision, max simply takes the maximum of the cross correlation map</li>\n<li><strong>save_translation_masks</strong>:  bool, defaults to True; whether to save translation masks as a tif or not</li>\n<li><strong>translation_mask_save_path</strong>:  str; path where to save translation masks</li>\n<li><strong>save_ccms</strong>:  bool, defaults to True; whether to save cross correlation matrices as a tif or not</li>\n<li><strong>ccms_save_path</strong>:  str; path where to save cross correlation matrices</li>\n<li><strong>apply</strong>:  bool; whether to apply the correction if True or only estimate if False</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>if apply==True, returns corrected image with shape (c, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.apply_channel_registration", "modulename": "nanopyx.methods.channel_registration", "qualname": "apply_channel_registration", "kind": "function", "doc": "<p>Function used to align different color channels of an image based on cross correlation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array with shape (n_channels, y, x); image to be registered</li>\n<li><strong>translation_masks</strong>:  numpy array of translation masks</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>returns corrected image with shape (c, y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.corrector", "modulename": "nanopyx.methods.channel_registration.corrector", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.__init__", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.load_translation_masks", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.load_translation_masks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.corrector.ChannelRegistrationCorrector.align_channels", "modulename": "nanopyx.methods.channel_registration.corrector", "qualname": "ChannelRegistrationCorrector.align_channels", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">img_stack</span>, </span><span class=\"param\"><span class=\"n\">translation_masks</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator", "modulename": "nanopyx.methods.channel_registration.estimator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.__init__", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.apply_elastic_transform", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.apply_elastic_transform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">img_stack</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.calculate_translation", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.calculate_translation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">channel_to_align</span>,</span><span class=\"param\">\t<span class=\"n\">ref_channel_img</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;subpixel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.save_translation_mask", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.save_translation_mask", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.save_ccms", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.save_ccms", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.channel_registration.estimator.ChannelRegistrationEstimator.estimate", "modulename": "nanopyx.methods.channel_registration.estimator", "qualname": "ChannelRegistrationEstimator.estimate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">img_stack</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">ref_channel</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_per_axis</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">min_similarity</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;subpixel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">save_translation_masks</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">translation_mask_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_ccms</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ccms_save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">apply</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimate_drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "qualname": "estimate_drift_alignment", "kind": "function", "doc": "<p>Function use to estimate the drift in a microscopy image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array  with shape (z, y, x)</li>\n<li><strong>save_as_npy (optional)</strong>:  bool, whether to save as npy (if true) or csv (if false)</li>\n<li><strong>save_drift_table_path (optional)</strong>:  str, path to save drift table</li>\n<li><strong>roi (optional)</strong>:  in case of use should have shape (x0, y0, x1, y1)</li>\n<li><strong>kwargs</strong>:  additional keyword arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image as numpy array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.apply_drift_alignment", "modulename": "nanopyx.methods.drift_alignment", "qualname": "apply_drift_alignment", "kind": "function", "doc": "<p>Function used to correct the drift in a microscopy image given a previously calculated drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array  with shape (z, y, x); image to be corrected</li>\n<li><strong>path (optional)</strong>:  str; path to previously saved</li>\n<li><strong>drift_table (optional)</strong>:  estimator table object; object containing previously calculated drift table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image as numpy array</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.corrector", "modulename": "nanopyx.methods.drift_alignment.corrector", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector", "kind": "class", "doc": "<p>Main class for aligning timelapse images with drift.\nRequired previous calculation of a drift table.\nImplements the following methods:</p>\n\n<ul>\n<li>apply_correction</li>\n<li>load_drift_table</li>\n<li>_translate_slice</li>\n</ul>\n"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.__init__", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.apply_correction", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.apply_correction", "kind": "function", "doc": "<p>Main method of DriftCorrector class.\nTranslates each image slice according to the drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_array</strong>:  numpy array with shape (n_slices, rows, columns)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aligned image array with shape (n_slices, rows, columns)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.corrector.DriftCorrector.load_estimator_table", "modulename": "nanopyx.methods.drift_alignment.corrector", "qualname": "DriftCorrector.load_estimator_table", "kind": "function", "doc": "<p>Method used to load the drift table.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  path to a .csv or .npy drift table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None, stores drift table data in self.drift_table</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator", "modulename": "nanopyx.methods.drift_alignment.estimator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.__init__", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.estimate", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.estimate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.compute_temporal_averaging", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.compute_temporal_averaging", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image_arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.get_shift_from_ccm_slice", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.get_shift_from_ccm_slice", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">slice_index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.get_shifts_from_ccm", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.get_shifts_from_ccm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.create_drift_table", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.create_drift_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.save_drift_table", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.save_drift_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">save_as_npy</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator.DriftEstimator.set_estimator_params", "modulename": "nanopyx.methods.drift_alignment.estimator", "qualname": "DriftEstimator.set_estimator_params", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable", "kind": "class", "doc": "<p>Class used to store DriftAlignment parameters as a dictionary.\nParameters can be changes individually by setting the corresponding params key value to desired parameter</p>\n"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.__init__", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.set_params", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.set_params", "kind": "function", "doc": "<p>Method used to set the parameters of drift alignment using keyword arguments.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>:  same as self.params.keys()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.set_comments", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.set_comments", "kind": "function", "doc": "<p>Method used to set comments for drift alignment operation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>comment_string</strong>:  str, comment text to be added</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">comment_string</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.export_npy", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.export_npy", "kind": "function", "doc": "<p>Method used to export drift table as a npy file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  Path to export drift table as npy</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.import_npy", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.import_npy", "kind": "function", "doc": "<p>Method used to import drift table as a npy file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, Path to drift table saved as a npy file</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.export_csv", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.export_csv", "kind": "function", "doc": "<p>Method used to export drift table as a csv file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, Path to export drift table as csv</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.drift_alignment.estimator_table.DriftEstimatorTable.import_csv", "modulename": "nanopyx.methods.drift_alignment.estimator_table", "qualname": "DriftEstimatorTable.import_csv", "kind": "function", "doc": "<p>Method used to import drift table from a csv file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  str, path to import drift table as csv</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "nanopyx.methods.esrrf", "modulename": "nanopyx.methods.esrrf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.squirrel", "modulename": "nanopyx.methods.squirrel", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "nanopyx.methods.srrf", "modulename": "nanopyx.methods.srrf", "kind": "module", "doc": "<p>Implemetation of the SRRF method</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">nanopyx.methods.srrf</span> <span class=\"kn\">import</span> <span class=\"n\">SRRF</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">srrf</span> <span class=\"o\">=</span> <span class=\"n\">SRRF</span><span class=\"p\">(</span><span class=\"n\">magnification</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">ringRadius</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();